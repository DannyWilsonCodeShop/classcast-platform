# DISABLED - Using AWS Amplify for deployment instead
# name: Deploy to Production

# on:
#   push:
#     branches: [ main ]
#   workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
        - production
      skip_approval:
        description: 'Skip manual approval (admin only)'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '18'
  AWS_REGION: 'us-east-1'
  PRODUCTION_DOMAIN: 'yourdomain.com'
  ROLLBACK_TAG: 'rollback'

jobs:
  # Pre-deployment Checks
  pre-deployment-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Run security scan
        run: npm audit --audit-level moderate
        
      - name: Check for known vulnerabilities
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high
          
      - name: Validate infrastructure changes
        run: |
          cd cdk
          npm ci
          npm run validate
          npm run diff

  # Manual Approval (if not skipped)
  manual-approval:
    name: Manual Approval
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    if: ${{ !inputs.skip_approval }}
    environment: production
    
    steps:
      - name: Wait for manual approval
        run: echo "Manual approval required for production deployment"

  # Deploy Infrastructure to Production
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, manual-approval]
    if: always() && (needs.manual-approval.result == 'success' || needs.manual-approval.result == 'skipped')
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-Production
          
      - name: Install CDK dependencies
        run: |
          cd cdk
          npm ci
          
      - name: Build CDK
        run: |
          cd cdk
          npm run build
          
      - name: Deploy infrastructure to production
        run: |
          cd cdk
          npm run deploy:all
        env:
          STAGE: production
          ENVIRONMENT: production

  # Build and Deploy Application
  deploy-application:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-Production
          
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        
      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: demo-project-production
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
          
      - name: Update ECS service
        run: |
          aws ecs update-service \
            --cluster demo-project-production-cluster \
            --service demo-project-production-service \
            --force-new-deployment
          
      - name: Wait for ECS service to stabilize
        run: |
          aws ecs wait services-stable \
            --cluster demo-project-production-cluster \
            --services demo-project-production-service

  # Production Smoke Tests
  production-smoke-tests:
    name: Production Smoke Tests
    runs-on: ubuntu-latest
    needs: deploy-application
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Wait for application to be ready
        run: |
          timeout 300 bash -c 'until curl -s https://${{ env.PRODUCTION_DOMAIN }}/api/health > /dev/null; do sleep 10; done'
          
      - name: Run critical E2E tests
        run: |
          E2E_BASE_URL=https://${{ env.PRODUCTION_DOMAIN }} npm run test:e2e -- --grep="critical"
        env:
          E2E_BASE_URL: https://${{ env.PRODUCTION_DOMAIN }}
          
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: production-smoke-test-results
          path: playwright-report/
          retention-days: 30

  # Health Check and Monitoring
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: production-smoke-tests
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-Production
          
      - name: Run comprehensive health checks
        run: |
          # Check application health
          curl -f https://${{ env.PRODUCTION_DOMAIN }}/api/health || exit 1
          
          # Check infrastructure health
          aws cloudwatch describe-alarms --alarm-names "demo-project-production-health" --query 'MetricAlarms[0].StateValue' --output text
          
          # Check database connectivity
          aws lambda invoke --function-name demo-project-health-checker --payload '{}' response.json
          
      - name: Send deployment notification
        run: |
          echo "üöÄ Production deployment completed successfully!"
          echo "üåê Application URL: https://${{ env.PRODUCTION_DOMAIN }}"
          echo "üìä Health Check: https://${{ env.PRODUCTION_DOMAIN }}/api/health"
          echo "üìà Monitoring: https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}"
        if: success()
        
      - name: Send failure notification
        run: |
          echo "‚ùå Production deployment failed!"
          echo "Please check the logs and consider rolling back."
        if: failure()

  # Rollback (if needed)
  rollback:
    name: Rollback
    runs-on: ubuntu-latest
    needs: [deploy-application, production-smoke-tests, health-check]
    if: failure() && needs.deploy-application.result == 'success'
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-Production
          
      - name: Rollback ECS service
        run: |
          # Get the previous task definition
          PREVIOUS_TASK_DEF=$(aws ecs describe-services \
            --cluster demo-project-production-cluster \
            --services demo-project-production-service \
            --query 'services[0].taskDefinition' \
            --output text)
          
          # Rollback to previous version
          aws ecs update-service \
            --cluster demo-project-production-cluster \
            --service demo-project-production-service \
            --task-definition $PREVIOUS_TASK_DEF \
            --force-new-deployment
          
      - name: Wait for rollback to complete
        run: |
          aws ecs wait services-stable \
            --cluster demo-project-production-cluster \
            --services demo-project-production-service
          
      - name: Verify rollback
        run: |
          curl -f https://${{ env.PRODUCTION_DOMAIN }}/api/health || exit 1
          
      - name: Send rollback notification
        run: |
          echo "üîÑ Production rollback completed!"
          echo "Previous version is now running."
        if: success()
